\section{Probleme bei der Implementierung}

\subsection{Wechsel der Sprache des Frontend}
\subsubsection{Grundproblem}
Eine der größten Schwierigkeiten der Implementierungsphase besteht im Wechsel der Programmiersprache im Frontend.
Ursprünglich wurde die Implementierung des Frontends mit dem Java-Transpiler Jsweet geplant.
In diversen Testprojekten wurde die Funktionalität von Jsweet umfangreich dargestellt.
Leider traten während der Implementierung des Java-Entwurfs diverse Fehler im Transpiler und den verwendeten Bibliotheken auf, die darauf hindeuten, dass Projekte mit Jsweet schlecht skalieren.
Aufgrund der Support-historie auf Github ist mit schnellen Fehlerbehebungen nicht zu rechnen.
Somit ergibt sich keine andere praktikable Lösung, als ein Wechsel der Programmiersprache, um das Projekt erfolgreich zu beenden.
Hier wurde React gewählt, die Laufzeitumgebung mit Javascript die gleiche wie bei einem übsertzten Jsweet Programm ist.
Zusätzlich ist der Funktionsumfang und die Dokumentation von React umfangreich.
Dadurch wird der Einstieg in React vereinfacht.
Gerade bei einem derart spontanen Wechsel der Programmiersprache ist der einfache Einstieg in einen Programmiersprache wichtig, um den Zeitplan einhalten zu könnnen, zumal durch die Implementierungsversuche zu Beginn der Implementierungsphase etwa eine Woche Arbeitszeit verloren gegangen ist.

Aus dem Wechsel der Programmiersprache ergibt sich das Grundproblem das der Ursprüngliche Entwurf in Java geplant wurde. Die Umsetzbarkeit des Java-Entwurfs in Raect ist Änderungsfrei weder möglich noch sinnvoll.
Im Frontend betrachten wir deshalb Änderungen nicht Funktionsweise, vielmehr betrachten wir die Umsetzung der Klassen des Entwurfs im praktischen React-Programm.

\subsubsection{Vorgehen beim Sprachentransfer}
Um den Entwurf des Java-Frontends nutzen zu können mussten grundelegende Bestandteile des Entwurfs in einen neuen Entwurf transferiert werden.
Das Vorgehen hierbei war wie folgt.

\begin{enumerate}
    \item Ein neues React-Projekt wurde als Basis des Projektes erstellt.
    \item Alle Klassen aus dem ursprünglichen Entwurf wurden dem Projekt als .jsx Dateien hinzugefügt.
    \item Den Klassen wurde im Entwurf jeweils ein Zweck oder eine Grundfunktionalität zugeordnet. Dieser Zweck wurde übernommen.
    \item Ausgehend von der Datei App.jsx wurden die Klassen absteigend in der Hierarchie implementiert. Die niedrigeren Implementierungsstufen wurden hierbei jeweils mit konstanten Werten simuliert.
\end{enumerate}

\subsection{Post Requests mit JSON an der Webschnittstelle des Backend}
Wird eine Anfrage an das Backend gestellt, so wird das Ergebnis als im \gls{JSON}-Format zurück gegeben.
Um sinnvoll Anfragen für erhaltene Objekte stellen zu können sollten als Anfrage-Parameter der POST-Request die erhaltenen Objekte verwendet werden können.
Der bisherige Entwurf war lediglich auf Anfragen mit Parametern des Typs \textit{application/x-www-form-urlencoded} geeignet.
Um JSON als Parameter verwenden zu können musste das Backend mit dem Typ \textit{application/json} kompatibel gemacht werden.

Um Parameter für Funktionen als JSON übergeben zu können müssen die Funktionsparameter einer bestimmten Form entsprechen.
\begin{itemize}[noitemsep]
    \item Es soll insgesamt nur ein Parameter übergeben werden
    \item Alle Felder des Parameters müssen für das Spring-Framework zu setzen (also public) sein
    \item Feld-Typen wie Strings müssen indirekt gesetzt werden, da die reinen Identitäten nicht direkt übergeben werden können
\end{itemize}
Daher wurden bei allen über die REST-API erreichbaren Funktionen die Parameter in Wrapper gekapselt.
Ein solcher Wrapper baut sich beispielsweise wie folgt auf:
\begin{lstlisting}[language=java,
    basicstyle=\normalfont\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background}]
/**
* Encapsulates a Thing and an ObservedProperty.
*/
static class ThingAndObservedPropertyWrapper {
    public Thing thing;
    public ObservedProperty observedProperty;

    public ThingAndObservedPropertyWrapper() {
    }

    public ThingAndObservedPropertyWrapper(Thing thing, ObservedProperty observedProperty) {
        this.thing = thing;
        this.observedProperty = observedProperty;
    }
}
\end{lstlisting}

Die Wrapper wurden als Subklassen der SensorthingsController implementiert.
Hierbei wurde jeweils die der spezielle Controller gewählt, solange der Wrapper nur in diesem verwendet wird.
Sobald der Wrapper in zwei oder mehr Controllern zum Einsatz kommt wird er in der Klasse SensorthingController implementiert, von der alle Controller erben.